"""Signal-domain models for Module 3."""

from __future__ import annotations

from datetime import UTC, datetime
from enum import StrEnum
from typing import Any
from uuid import uuid4

from pydantic import BaseModel, Field, field_validator, model_validator

from data.asset_types import AssetClass
from regime.regime_models import MarketRegime


def utc_now() -> datetime:
    """Return timezone-aware UTC timestamp."""

    return datetime.now(UTC)


class SignalDirection(StrEnum):
    """High-level trading direction."""

    BUY = "BUY"
    SELL = "SELL"
    WAIT = "WAIT"
    NO_TRADE = "NO_TRADE"


class SignalStrength(StrEnum):
    """Display strength bucket derived from confidence."""

    STRONG = "strong"
    MODERATE = "moderate"
    WEAK = "weak"
    NONE = "none"


class SignalReason(BaseModel):
    """One contributing factor to a signal decision."""

    factor: str
    value: float | str | None = None
    contribution: float = Field(ge=-1.0, le=1.0)
    weight: float = Field(ge=0.0, le=1.0)
    description: str
    direction: str
    source: str

    @field_validator("direction")
    @classmethod
    def validate_direction(cls, value: str) -> str:
        allowed = {"bullish", "bearish", "neutral"}
        lowered = value.lower()
        if lowered not in allowed:
            raise ValueError(f"direction must be one of {sorted(allowed)}")
        return lowered


class Signal(BaseModel):
    """Signal generated by one strategy."""

    signal_id: str = Field(default_factory=lambda: str(uuid4()))
    strategy_id: str
    strategy_version: str
    symbol: str
    broker: str
    timeframe: str
    timestamp: datetime = Field(default_factory=utc_now)
    run_id: str
    direction: SignalDirection
    strength: SignalStrength = SignalStrength.NONE
    raw_score: float = Field(ge=-100.0, le=100.0)
    confidence: float = Field(ge=0.0, le=1.0)
    reasons: list[SignalReason] = Field(default_factory=list)
    regime: MarketRegime
    horizon: str
    entry_price: float | None = None
    suggested_sl: float | None = None
    suggested_tp: float | None = None
    expires_at: datetime | None = None
    metadata: dict[str, Any] = Field(default_factory=dict)

    @field_validator("timestamp", "expires_at")
    @classmethod
    def ensure_utc(cls, value: datetime | None) -> datetime | None:
        if value is None:
            return None
        if value.tzinfo is None:
            raise ValueError("timestamp fields must be timezone-aware")
        return value.astimezone(UTC)

    @model_validator(mode="after")
    def validate_reasons(self) -> Signal:
        if not self.reasons:
            return self
        total_weight = sum(reason.weight for reason in self.reasons)
        if total_weight <= 0:
            raise ValueError("reasons must include at least one positive weight")
        return self


class EnsembleResult(BaseModel):
    """Consolidated output from combining multiple signals."""

    symbol: str
    broker: str
    timeframe: str
    timestamp: datetime = Field(default_factory=utc_now)
    run_id: str
    final_direction: SignalDirection
    final_confidence: float = Field(ge=0.0, le=1.0)
    final_strength: SignalStrength
    contributing_signals: list[Signal] = Field(default_factory=list)
    all_reasons: list[SignalReason] = Field(default_factory=list)
    agreement_score: float = Field(ge=0.0, le=1.0)
    contradiction_score: float = Field(ge=0.0, le=1.0)
    regime: MarketRegime
    horizon: str
    filters_passed: list[str] = Field(default_factory=list)
    filters_blocked: list[str] = Field(default_factory=list)
    explanation: str = ""
    short_explanation: str = ""

    @field_validator("timestamp")
    @classmethod
    def ensure_timestamp_utc(cls, value: datetime) -> datetime:
        if value.tzinfo is None:
            raise ValueError("timestamp must be timezone-aware")
        return value.astimezone(UTC)


class DecisionResult(BaseModel):
    """Final user-facing decision wrapper."""

    ensemble: EnsembleResult
    display_decision: str
    display_color: str
    display_emoji: str
    confidence_percent: int = Field(ge=0, le=100)
    top_reasons: list[SignalReason] = Field(default_factory=list)
    computed_at: datetime = Field(default_factory=utc_now)
    valid_until: datetime
    asset_class: AssetClass
    horizon_human: str

    @field_validator("computed_at", "valid_until")
    @classmethod
    def ensure_timestamp_utc(cls, value: datetime) -> datetime:
        if value.tzinfo is None:
            raise ValueError("timestamp must be timezone-aware")
        return value.astimezone(UTC)

    @model_validator(mode="after")
    def ensure_validity_window(self) -> DecisionResult:
        if self.valid_until <= self.computed_at:
            raise ValueError("valid_until must be greater than computed_at")
        return self


__all__ = [
    "DecisionResult",
    "EnsembleResult",
    "Signal",
    "SignalDirection",
    "SignalReason",
    "SignalStrength",
]
